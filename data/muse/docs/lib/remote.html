<!DOCTYPE html>
 <html>
<head>
<link href="https://minerbadd.github.io/CodeMark/assets/downmark.css" rel="stylesheet" />
</head>
<body>
<pre>

--:! {remote: [":"]: ():} <- <b>Functions Library for Remote Procedure Calls</b> -> muse/docs/lib/remote.md      
--:| remote: <i>Client and server side support for RPCs and client (player) side support for</i> <code>come</code> <i>and</i> <code>tail</code>. -> remote, _remote    
--:+ <b>Test functions are provided for out-of-game operations without a network.</b>  

--:# <b>Server Side Remote Call Operations: Protocols to Receive Muse Calls (MC), Send Muse Responses (MR)</b>  

--:: <code>remote.apply(clientID: #:, request: ":")</code> -> <i>Request string to request table, return serialized result</i>. -> <code>result: ":"</code>  

--:: remote.wait() -> <i>Setup turtle to repeatedly wait for MC network requests, send MR results.</i> -> <code>nil</code>  

--:# <b>Client Side Remote Call Operations: Protocols to Send Muse Calls (MC), Receive Muse Responses (MR)</b>  

--:: <code>remote.returns(serverID: #:, resultString: ":", callback: ():)</code> -> <i>Apply callback to deserialized client result.</i> -> <code>any</code>  

--:: <code>remote.marshall(server: ":", command: ":", arguments: any[])</code> -> <i>Serialize server request.</i> -> <code>serverID: #:, request: ":" &: &!</code>  

--:: remote.call(server: ":", command: ":", arguments: any[], callback: ():?) -> <i>RPC:</i> -> <code>any &: &!</code>    
--:+ <i>Form serialized request table from command string and arguments. Get server ID from server name.</i>    
--:+ <i>Send request to server, wait for result, return call (default <code>remote.returns</code>) callback function to result.</i>  

--:: remote.callback(results: any[]) -> <i>Default client side handling of server response: just print results as string.</i> -> <code>nil</code>  

--:# <b>Turtle fetch functions:</b> <code>come</code> <b>(once) and</b> <code>tail</code> <b>(repeatedly) to player</b>    
--:+ <i>Prepare remote call to server turtle by getting player xyz position and forming argument table.</i>  

--:: remote.come(turtle: ":") -> <i>Towards GPS player position.</i> -> <code>report: ":"</code>  

--:- come -> <i>Turtle towards GPS player position.</i>  

--:: remote.tail(turtle: ":", _ : "tail", rates: ":"?) -> _Repeatedly towards player position, default rate _G.Muse.rates.tail seconds -> <code>nil</code>   

--:- tail rate? -> <i>Turtle every rate seconds towards player.</i>  

    </pre>
  </body> 
</html>

