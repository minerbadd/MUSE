<!DOCTYPE html> 
  <html> 
  <head> 
  <link href="../../assets/prism.css" rel="stylesheet" /> 
  <link href="../../assets/muse.css" rel="stylesheet" /> 
  </head> 
  <body> 
     <script src="../../assets/prism.js"></script> 

<h2> Quarry, Layer, Finish, Path, and Test Operations to Create Animal Farm</h2>
<pre><code class="language-markdown">
--:~ field.plot() <- <b>Create Four Animal Pens with Central Access Alley</b> -> muse/docs/fields/pens.md
--:+ <i>Loaded by <code>field.make</code> with operation name, span of plots for the operation, and field bounds.</i>
--:+ <b>Supported operations are <code>quarry</code>, <code>layer</code>, <code>finish</code>, <code>path</code>, and <code>test</code></b>
--:+ <i>Calls <code>field.plot</code> with specified plot span, field operation function, and total field plots for that operation.</i>
--:+ <i>Operation functions call <code>field.plan</code> with plot bounds, xyz offset, and prototype plan for the operation.</i>
--:+ <i>Leaves margins around finished area fencing, fences quadrants with internal alley, uses <code>"fence"</code> material.</i>
--:+ <i>Gates are to be placed by player (replacing fence) as desired.</i>
</code></pre>
<pre><code class="language-lua">
package.path = _G.Muse.package
local cores = require("core"); local core = cores.core ---@module "signs.core"
local fields = require("field"); local field = fields.field ---@module "signs.field"

local vectorPairs = core.vectorPairs

local commands, bounds, faced = ... -- <b>parameters from the <code>lib/field</code> call of the field function for this file</b> 
local bottom, top = bounds.bottom, bounds.top
local strides = {quarry = 1, layer = 1, finish = 1}
local nplots, slots, stride, run, striding, turn = field.extents(bounds, strides, faced)
local vW, vE, vN, vS = stride[1], stride[2], run[1], run[2] -- vN to vS run axis and vW to VE stride axis for each plot
local orient = function(xyzAB) return turn and core.orient(xyzAB) or xyzAB end -- no transform for west-east as stride

local runFences, minimumAlley, vWidth, vLength = 4, 3, vE - vW + 1, vS - vN + 1
local moreAlley = (vWidth - runFences - minimumAlley) % 2; local alleyWidth = minimumAlley + moreAlley
local penWidth = (vWidth - runFences - alleyWidth) / 2
if penWidth <= 0 then error("pens: Can't be "..penWidth.." blocks wide") end

local fences = (runFences <i> vLength) + (2 </i> penWidth) + (2 * (vWidth - 2))
core.status(2, "pens", slots.quarry, "slots each plot", fences, "fences")
</code></pre>
<a id="plots"><IMG SRC="../../drawings/07Pens.png" ALIGN="center" hspace="10"/>
The field is parcelled into <code>plots</code> appropriate to each <i>field operation</i>. Each <code>plot</code> is generated referencing the virtual <code>stride</code> and  <code>run</code> axes. If there is no <code>turn</code> property, <code>orient</code> performs no transform.  The <code>stride</code> axis is then simply west to east in game coordinates and operations will <code>run</code> along north to south game coordinates.
<p>
<pre><code class="language-lua">
local divider = vN + core.round(vLength/2) -- half way along run
local startAlley = vW + penWidth + 2; local endAlley = startAlley + alleyWidth 
local plots = {
  quarry = vectorPairs(orient { {vW, top, vN - 1 }, {vW, bottom, vS + 1} }, striding.quarry, nplots.quarry + 2),
  layer = vectorPairs(orient { {vW, bottom, vN}, {vW, bottom, vS} }, striding.layer, nplots.layer),
  finish = {
    orient { {vW, bottom, vN}, {vW, bottom, vS} }, -- along first stride (vW) to end of run (vN vS)
    orient { {vW + 1, bottom, vS}, {vE - 1, bottom, vS} }, -- along end of run (vS) to last stride (vW vE)
    orient { {vE, bottom, vS}, {vE, bottom, vN} }, -- along last stride (vE) to start of run (vS vN)
    orient { {vE - 1, bottom, vN}, {vW + 1, bottom, vN} }, -- along start of run (vN) to first stride (vE vW)
    orient { {vW + 1, bottom, divider}, {startAlley - 1, bottom, divider} }, -- along divider from start of run to alley
    orient { {endAlley + 1, bottom, divider}, {vS - 1, bottom, divider } }, -- along divider from end of alley 
    orient { {endAlley, bottom, vS - 1 }, {endAlley, bottom, vN + 1} }, -- along alley end, from near end of run to near start
    orient { {startAlley, bottom, vN + 1}, {startAlley, bottom, vS - 1} }, -- along start of alley back to near end
  },
}; nplots.finish = #plots.finish; plots.path = plots.finish; nplots.path = nplots.finish
</code></pre>
<a id="ops"></a> 
Each <code>operation</code> supported by this field (<code>quarry</code>, <code>layer</code>, <code>finish</code>, <code>path</code>, and <code>test</code>) corresponds to a <code>field operation</code> function. These call <code>field.plan</code> with the name of a <i>plan prototype</i> file in the <code>plans</code> directory and the <code>fieldParameters</code> including the <code>plots</code> that the <i>plan prototype</i> will need. 
<pre><code class="language-lua">
local function quarryOp(index)
  local quarryResult = field.plan("quarry", {plots.quarry[index]}) -- from, to
  core.status(2, "pens", "quarrying", index, quarryResult)
  return quarryResult
end

local function layerOp(index)
  local layerResult = field.plan("layer", {plots.layer[index], "dirt"})
  core.status(2, "pens", "layering", index, layerResult)
  return layerResult
end

local function finishPath(index, offset, plan)
  local finishResult = field.plan(plan, {plots.finish[index], "fence"}, offset)
  core.status(2, "pens", "finishingPath", index, finishResult)
  return finishResult
end

local function finishOp(index, offset) return finishPath(index, offset, "layer") end

local function pathOp(index, offset) return finishPath(index, offset, "path") end

local function testOp() return "pens "..core.string(plots.finish) end
</code></pre>
<a id="plot"></a> 
Call <code>field.plot</code> with a <i>field operation</i> callback as well as the number of plots and offsets for the operation.
<pre><code class="language-lua">
local fieldOps = {layer = layerOp, quarry = quarryOp, finish = finishOp, path = pathOp, test = testOp}; 
local offsets = {finish = {0, 1, 0}, path = {0, 2, 0}}; local fieldOpName = commands[1]; local fieldsOp = fieldOps[fieldOpName]
if not fieldsOp then error("pens: doesn't "..fieldOpName) end

return field.plot(commands, fieldsOp, fieldOpName, nplots[fieldOpName], offsets[fieldOpName]) -- back to <code>lib/field</code>

  </body> 
</html>

