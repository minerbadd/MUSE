<!DOCTYPE html>
 <html>
<head>
<link href="https://minerbadd.github.io/CodeMark/assets/prism.css" rel="stylesheet" />
<link href="https://minerbadd.github.io/CodeMark/assets/downmark.css" rel="stylesheet" />
</head>
<body>
<script src="https://minerbadd.github.io/CodeMark/assets/prism.js"></script>

<h3>Setup Test Configuration for Doing the Tests with Regression Testing: lib/check</h3>
<pre><code class="language-markdown">
--:! {check: [":"]: ():} <- Regression Check Functions Library -> muse/docs/lib/check.md
--:| check: Setup context, save and match expected results for parts of tests, run regression for those tests -> check
</code></pre>
<pre><code class="language-lua">

_G.Muse = _G.Muse or {}; _G.Muse.path = "rom/modules/"

local lfs = require("lfs"); local core = require("core").core ---@module "signs.core"
local check = {}; ---@module "signs.check"  

local tests = arg[0]:match('.*[/\\]') --:# Get path to executable calling this library
local checks = tests.."checks/" --:# Assumes tests directory structure as <code>tests/checks</code>

--:# <i>Set Configuration Variables for tests: landed turtles, default site, tracking, delays, turtle <code>data</code> directory</i>
_G.Muse.landed = {farmer = true, logger = true, miner = true,} -- roles of turtles local to each site
_G.Muse.IDs, _G.Muse.roles, _G.Muse.defaultSite = {}, {}, "base" -- with <code>site</code> program
_G.Muse.tracking = {limit = 500, enabled = false}
_G.Muse.delays = {gps = 1, dds = 3, map = 5} -- for game setup before running dds
_G.Muse.slots = 16 -- in turtle inventory (just to avoid a magic number in libraries)
_G.Muse.attempts = 5 -- <code>lib/turtle</code> attempts to remove a blockage
_G.Muse.rates = {}; _G.Muse.rates.headings = 5; _G.Muse.rates.tail = 0.5
_G.Muse.permutations = {"y", "z", "x"} -- controlling axes order in permutations
-- {"y", "z", "x"} -> z x y, x z y, x y z, y x z, z y x, y z x
-- {"x", "y", "z"} -> y z x, z y x, z x y, x z y, y x z, x y z
_G.Muse.data = tests.."data/"  -- for test environment separate from game environment
</code></pre>
<a id="tests"></a>
There's an example here, <code>check.open</code>, of what's called <i>a poor man's object</i>. The function creates what can be thought of as a <code>check</code> object with the context needed to save (and compare) results by the <code>part</code> "method" for each part of a given test. Those <i>expected</i> results are compared with actuals during a regression validation. There's a cleanup operation to <code>close</code> the opened <code>check</code> object. 
<p>
<i>(The code illustrates <a href="https://wiki.c2.com/?ClosuresAndObjectsAreEquivalent" target="_blank"> <code>poor man's objects</code></a>. This link dumps you into a theory heavy digression. Go there when you're ready for that.)</i>
<p>
For MUSE, all this is enabled by files in a specified <code>checks</code> directory. The expected results from the previous run of a test are found in the file in that directory for the given test. The results files instantiate when loaded as tables of result strings keyed by part identifiers (as strings) in the test.
<pre><code class="language-lua">

local function expected(testName) --:# Find results (if any) from a previous test.
  assert(lfs.chdir(tests), "No tests directory here: "..tests) -- make a checks directory if needed
  assert((io.open(checks, "r") or lfs.mkdir("checks")), "Can't make tests/check/ in "..tests)
  local resultsFileName = checks..testName..".lua"
  local resultsFunction = io.open(resultsFileName, "r") and loadfile(resultsFileName)
  local priors = resultsFunction and resultsFunction()
  return priors -- if any
end

--:# The poor man's object.... encapsulates but provides no inheritance facilities (didn't see the need to go there)
function check.open(testName, text, regression) -- create check object with context variables
  --:: check.open(testName:":", text: ":") -> <i>Return object(closure)</i> -> <code>{part:():, message:(): , close:():}</code> 
  print(text); local priors = not regression and {} or assert(expected(testName), "No prior results for "..testName)
  local this = {priors = priors, testName = testName, regression = regression} -- instance variables

  --:# Access functions for the <code>check</code> object, each check object is independent in itself
  local function part(partID, note, ...) -- at each part of the test
    if not this.regression then print(note) end -- verbose if not regression
    local partName = tostring(partID); local result, prior = core.string(...), this.priors[partName]
    if (this.regression and result ~= prior) then error(result.." ~= "..prior or ''.. " in "..this.testName..":"..partName) end
    if not this.regression then this.priors[partName] = result; print(result); return end -- save for regression
  end

  local function message(...) if not this.regression then print(...) end end

  local function close(text) -- at end of test
    if this.regression then print(text); this = nil; return end
    local serialized, path = core.serialize(this.priors), checks..testName..".lua"
    local handle = assert(io.open(path, "w"), "Can't open "..path.." in check.lua")
    handle:write(serialized); handle:close(); this = nil -- for gc
  end

  return {part = part, message = message, close = close}

end -- check object created by <code>check.open</code>

--:# Run each test in this test directory that has expected results 
function check.regression(testOrder) --:: check.regression(testOrder: ":"[]) -> <i>Run ordered test names for regression.</i> -> <code>":"[]</code>
  local regression = true -- not the one in the <code>check</code> object
  for _, testName in ipairs(testOrder) do --:# Order to run tests comes from <code>tests/.regression</code>.
    if expected(testName) then -- TODO: maybe catch any thown errors and raise regression failed exception
      local test = assert(loadfile(tests..testName..".lua"), "Failed to load "..testName..".lua")
      test(regression) --:# Load test with <code>regression</code> parameter <code>true</code>. Apply <code>check.open</code> in test with this parameter.
    end 
  end 
end 

return {check = check}

  </body> 
</html>

