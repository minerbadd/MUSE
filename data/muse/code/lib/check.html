<!DOCTYPE html>
 <html>
<head>
<link href="https://minerbadd.github.io/CodeMark/assets/prism.css" rel="stylesheet" />
<link href="https://minerbadd.github.io/CodeMark/assets/downmark.css" rel="stylesheet" />
</head>
<body>
<script src="https://minerbadd.github.io/CodeMark/assets/prism.js"></script>

<h3>Setup Test Configuration for Doing the Tests with Regression Testing: lib/check</h3>
<pre><code class="language-markdown">
--:! {check: [":"]: ():} <- Regression Check Functions Library -> muse/docs/lib/check.md
--:| check: Setup context, save and match expected results for parts of tests, run regression for those tests -> check
</code></pre>
<pre><code class="language-lua">
local starts = require("_start"); local _ = starts -- loaded just to set configuration variables
local cores = require("core"); local core = cores.core ---@module "signs.core"
local lfs = require("lfs"); local check = {}; ---@module "signs.check"  

local tests = arg[0]:match('.*[/\\]') --:# Get path to calling executable
local checks = tests.."checks/" --:# Assumes tests directory structure as <code>tests/checks</code>
_G.Muse.data = tests.."data/" -- separate from game when testing

function check.echo(...) return ... end -- so <code>check.part</code> has some function to apply

</code></pre>
<a id="tests"></a>
There's an example here, <code>check.open</code>, of what's called <i>a poor man's object</i>. The function creates what can be thought of as a <code>check</code> object with the context needed to save (and compare) results by the <code>part</code> "method" for each part of a given test. Those <i>expected</i> results are compared with actuals during a regression validation. There's a cleanup operation to <code>close</code> the opened <code>check</code> object. 
<p>
<i>(The code illustrates <a href="https://wiki.c2.com/?ClosuresAndObjectsAreEquivalent" target="_blank"> <code>poor man's objects</code></a>. This link dumps you into a theory heavy digression. Go there when you're ready for that.)</i>
<p>
For MUSE, all this is enabled by files in a specified <code>checks</code> directory. The expected results from the previous run of a test are found in the file in that directory for the given test. The results files instantiate when loaded as tables of result strings keyed by part identifiers (as strings) in the test.
<p>
Test parts are executed as protected calls so errors can be used in regression testing. This requires part operations to be deferred by applying functions to arguments in <code>check.part</code> rather than in the tests themselves.  
<pre><code class="language-lua">

local function directories()
  assert(lfs.chdir(tests), "No tests directory here: "..tests) 
  if lfs.chdir(checks) then return end -- or make a checks directory if needed
  assert(lfs.mkdir("checks"), "Can't make tests/check/ in "..tests)
end

local function expected(testName) --:# Find results (if any) from a previous test.
  directories(); local resultsFileName = checks..testName..".lua"
  local resultsFunction = io.open(resultsFileName, "r") and loadfile(resultsFileName)
  local priors = resultsFunction and resultsFunction()
  return priors -- if any
end

--:# The poor man's object.... encapsulates but provides no inheritance facilities (didn't see the need to go there)
function check.open(testName, text, regression) -- create check object with context variables
  --:: check.open(testName:":", text: ":") -> <i>Return <code>check</code> object(closure)</i> -> <code>{part:():, message:():, close:():}</code> 
  print(text); local priors = not regression and {} or assert(expected(testName), "No prior results for "..testName)
  local partID = 0; local this = {priors = priors, testName = testName, regression = regression, partID = partID} 

  --:# Access functions for the <code>check</code> object, each check object is independent in itself
  local function part(note, fun, ...) -- at each part of the test
    --:# part(partID: ":", note: ":", fun: ():, ...: any): -> <i>Collect ... results for part, save or compare (for regression)</i> -> <code>nil</code>
    if not this.regression then print(note) end -- verbose if not regression
    partID = partID + 1; local partName, prior = tostring(partID), this.priors[partID]
    local ok, result = core.past(pcall(fun, ...)) -- <b>execute the test part deferred till now (with protection)</b>
    local failure = ("ERROR "..this.testName..".lua part "..partName..": "..note.." failed: "..core.string(result))
    local report = ok and core.string(result) or failure
    if (this.regression and report ~= prior) then error(report.." ~= "..prior or ''.. " in "..this.testName..": "..note) end
    if not this.regression then this.priors[partID] = report; print(note, report); return report end --> 
  end
  
  local function message(...) if not this.regression then print(...) end end
  --:# message(..: ":"): -> <i>Print ... if not regression</i> -> <code>nil</code>

  local function close(text) -- at end of test
    --:# close(text: ":"): -> <i>Print text if regression, otherwise save results in</i> <code>checks</code> <i>directory for test</i> -> <code>nil</code>
    if this.regression then print(text); this = nil; return end
    directories(); local serialized, path = core.serialize(this.priors), checks..testName..".lua"
    local handle = assert(io.open(path, "w"), "Can't open "..path.." in tests/check")
    handle:write(serialized); handle:close(); this = nil -- for gc
    print(text, checks..testName..".lua")
  end

  return {part = part, message = message, close = close}

end -- check object created by <code>check.open</code>

--:# Run each test in this test directory that has expected results 
function check.regression(testOrder) --:: check.regression(testOrder: ":"[]) -> <i>Run ordered test (names) for regression.</i> -> <code>nil</code>
  local regression = true -- not the one in the <code>check</code> object
  for _, testName in ipairs(testOrder) do --:# Order to run tests comes from <code>tests/.regression</code>.
    if expected(testName) then -- TODO: maybe catch any thown errors and raise regression failed exception
      local test = assert(loadfile(tests..testName..".lua"), "Failed to load "..testName..".lua")
      test(regression) --:# Load test with <code>regression</code> parameter <code>true</code>. Apply <code>check.open</code> in test with this parameter.
    end 
  end 
end 

return {check = check}

  </body> 
</html>

