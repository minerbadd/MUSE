<!DOCTYPE html>
 <html>
<head>
<link href="https://minerbadd.github.io/CodeMark/assets/prism.css" rel="stylesheet" />
<link href="https://minerbadd.github.io/CodeMark/assets/downmark.css" rel="stylesheet" />
</head>
<body>
<script src="https://minerbadd.github.io/CodeMark/assets/prism.js"></script>

<h2> MUSE Distributed Discovery Service: lib/dds</h2>
<pre><code class="language-markdown">
--:! {dds: [":"]: ():} <- <b>In-game (only) MUSE Discovery Service Library</b> -> muse/docs/lib/dds.md  
--:| dds: <i>Associates computer IDs with labels (as Muse roles) using Muse Query (MQ) rednet protocol.</i> -> dds
</code></pre>
This module provides a library handling the mapping of numbers (ComputerCraft computer IDs) to names (ComputerCraft computer labels standing in for MUSE roles) with <code>dds.role</code> and back again with <code>dds.ID</code>. These are filled in in-game by a call to <code>lib/dds.hosts</code> during session startup by running <a href="../.start.html#dds" target="_blank"> <code>.start.lua</code> </a>. 
<p>
Some MUSE roles are native to a MUSE <code>site</code>. Unsited turtles in these <code>landed</code> roles will be given the player's site. 
<p>
The library provides the DDS facilities needed for remote calls. The DDS facilities only work in-game because the ComputerCraft network interfaces are not mocked. However, the library does export a default mapping and its support functions can be tested out-of-game.
<pre><code class="language-lua">
---@diagnostic disable: duplicate-set-field
local ddss = require("signs.dds"); ddss.dds = {}; local dds = ddss.dds ---@module "signs.dds"

local cores = require("core"); local core = cores.core ---@module "signs.core"
local places = require("places"); local place = places.place ---@module "signs.places"

---@diagnostic disable-next-line: undefined-field
local rednet, parallel = _G.rednet, _G.parallel -- for static analysis

---@diagnostic disable-next-line: undefined-field
local player = _G.pocket -- only the player has the (only) pocket computer

</code></pre>
The library deals with identity. As mentioned, this is in terms of the correspondence between roles and IDs. For <i>landed</i> turtles, roles are <i>qualified</i> by the <i>site</i> where the landed turtle is found. Sometimes it's convenient to refer to a landed turtle without the qualifying site information. The <code>dds.ID</code> function supplies that as needed. Functions are provided for the player to <code>join</code> a newly hatched turtle to the network and once connected for it to use <code>dds.qualify</code> to persist its <code>qualified role</code> and its <code>site</code> in its local storage. Turtles can be moved to a new site with <code>dds.site</code>.
<p>
<p>
<pre><code class="language-lua">

_G.Muse.IDs = #_G.Muse.IDs > 0 and _G.Muse.IDs or -- for out-game 
--:> IDs: <i>Dictionary of ComputerCraft computer IDs keyed by MUSE role</i> -> <code>[role]: ID</code>
--:> ID: <i>ComputerCraft computer ID</i> -> <code>#:</code>
---@diagnostic disable-next-line: undefined-field
(_G.rednet and {} or {player = 0, porter = 1, rover = 5, miner = 6, logger = 7, farmer = 8}) 

_G.Muse.roles = #_G.Muse.roles > 0 and _G.Muse.roles or -- for out-game
---@diagnostic disable-next-line: undefined-field
(_G.rednet and {} or {[0] = "player", [1] = "porter", [5] = "rover", [6] = "miner", [7] = "logger", [8] = "farmer"})
--:> roles: <i>Sparse array of Computercraft labels for MUSE roles indexed by Computercraft IDs</i> -> <code>role[]</code>
--:> role: <i>ComputerCraft label as MUSE role (may be qualified by</i> <code>site</code> <i>for landed turtles)</i> -> <code>":"</code>

local IDs, roles, landed = _G.Muse.IDs, _G.Muse.roles, _G.Muse.landed

function dds.ID(role) --:: dds.roleID(role: ":") -> <i>ID for a Muse role (qualified if need be)</i> -> <code>ID: #:</code> 
  local qrole = landed[role] and place.qualify(role) or role
  return IDs[qrole], qrole
end

function dds.role(id) return roles[id] end --:: dds.role(id: #:) ->  <i>Muse role (label) for a computer ID</i> -> <code>role: ":"</code>

function dds.join(role, id) 
  --:: dds.join(role: ":", id: #:) -> <i>Sets qualified ID role association (label), id? given by player.</i> -> <code>role: ":"</code>
  --:+ <i>On player to join a turtle to network and give it a role (and then over network through</i> <code>lib/map</code> <i>to turtle)</i>
  --:+ <i>Each site can have its own landed turtles with their own qualfied roles.</i>
  local currentRole = roles[id]; if currentRole then roles[id] = nil; IDs[currentRole] = nil end  -- wipe current role
  IDs[role] = id; roles[id] = role; core.setComputerLabel(role) -- all needed for new role
  return role
end

function dds.site(site) -- on turtle to site it persistently (or player to change site)
  --:: dds.site(site: ":"?) -> <i>Write (new) site file, set new qualified IDs[role, set site and return it</i> -> <code>role: ":"</code>
  local handle = assert(io.open(_G.Muse.data.."site.txt", "w"), "dds site: can't write site.txt")
  if not site then handle:write(""); handle:close() return "" end -- remove <code>site.txt</code> for testing
  local siting = site and place.site(site).."\n" or ""; handle:write(siting); handle:close()
  local id, base = IDs[core.getComputerLabel()], place.base(core.getComputerLabel()); -- id and base don't change
  place.site(site); local _, role = dds.ID(base); return dds.join(role, id) -- new qualified role for site, same id
end

local function get(site)
  local handle = io.open(_G.Muse.data.."site.txt", "r") 
  if not handle then return dds.site(site) end -- if no site file, write one
  local data, message = handle:read("*line")
  assert(data, "dds.qualify: can't read ".._G.Muse.data.."site.txt".." "..(message or ""))
  return data == "" and dds.site(site) or data -- if empty site file, write one
end

function dds.qualify(site)
  --:: dds.qualify(site: ":"?) -> <i>Set site, return (qualified) role; if needed, create site file (default current)</i> -> <code>role: ":"</code>
  local role = core.getComputerLabel(); local id = IDs[role]; place.site(get(site));  -- get might make a site file
  local _, qrole = dds.ID(role); return dds.join(qrole, id)
end
</code></pre>
<a id="request"></a> 
Te main work of the library creating relationships between labeled roles and computer IDs starts here. The player sends a <code>request</code> for MUSE roles (as ComputerCraft labels) to all computers registered as `MQ protocol hosts and gets a count of them. It's useful to keep in mind where (player or turtle) the work is being done at each step of this process.
<pre><code class="language-lua">

function dds.playerID(id) if id then _G.Muse.playerID = id end; return _G.Muse.playerID end
--:: dds.playerID(id: #:?) -> <i>Isolate global</i> -> #:

local function request() -- player sends its ID and site to all computers registered as <code>MQ</code> protocol hosts.
  dds.playerID(core.getComputerID(0)) -- out-game force ID = 0
  local hosts = {rednet.lookup("MQ")}; core.report(1, "Hosting "..#hosts)
  for _, id in pairs(hosts) do rednet.send(id, place.site(), "MQ") end 
  return #hosts
end
</code></pre>
<a id="respond"></a> 
All computers other than the player's pocket computer wait to <code>respond</code>. If a responding turtle is a <code>landed</code> turtle that is as yet, unsited, it attaches itself to the player's <code>site</code>. In any case, it sends back a message that provides information for mapping between its computer ID and its label (its MUSE role).
<pre><code class="language-lua">
local function respond()  
  local id, playerSite = rednet.receive("MQ"); dds.playerID(assert(id, "dds respond: no id")) -- set global on remote responder
  assert(id and playerSite, "dds respond: id and player site not received")
  local qrole = dds.qualify(tostring(playerSite))
  core.report(1, "MQT "..id.." "..qrole); -- DDS Turtle now sited
  rednet.send(id, qrole, "MQ") -- need to send <code>count</code> messages 
end
</code></pre>
<a id="receive"></a>
The player waits to <code>receive</code> each of the responses and populates two tables, <code>IDs</code> and <code>labels</code>, that provide a mapping between names and numbers and back again. When it has the full <code>count</code> of responses, the work of <code>dds.hosts</code> is done. 
<pre><code class="language-lua">
local function receive(count) -- on player for each DDS host
  for _ = 1, count do
    local ddsID, received = rednet.receive("MQ") -- next, deal with rednet send to self behavior
    local ddsLabel = (ddsID == dds.playerID()) and "player" or received -- player sends garbage to self
    assert(ddsID and ddsLabel, " dds receive: need id and label")
    IDs[ddsLabel] = ddsID; roles[ddsID] = ddsLabel -- <b>the point of it all</b>
    core.report(1, "MQ "..ddsID.." "..ddsLabel) -- DDS Player
    rednet.send(ddsID, "DDS OK on "..core.getComputerLabel(), "MS") -- to .status
  end 
end
</code></pre>
<a id="hosts"></a> 
The <code>dds.hosts</code> function is the one that kicks off the interactions above between a player and other DDS hosts to populate a mapping between roles and computer IDs. The interactions begin by a <a href="#request"> request </a> for a count of computers registered with the <code>MQ</code> protocol. This was set up during session <a href="../.start.html" target="_blank"> startup </a>. The MQ registered computers <a href="#respond"> respond </a> with a message allowing a mapping between the turtle's computer ID and its label (its MUSE role). This is done by the <a href="#receive"> receive </a> function. The <code>parallel.waitForAny</code> function is called with an anonymous closure to <code>receive</code> a <code>count</code> of these messages.
<pre><code class="language-lua">
function dds.hosts() 
  --:: dds.hosts() -> <i>Populates players IDs and labels using a MQ rednet protocol.</i> -> <code>nil</code>
  print("Waiting on MQ"); if not player then print("Need pocket computer for DDS") end
  if not player then parallel.waitForAny(respond) 
  else local count = request(); print(tostring(count).." DDS hosts (expected?)")  -- player
    parallel.waitForAny(function() receive(count) end) -- wait to get all MQ host responses
    --IDs[core.getComputerLabel("player")] = core.getComputerID(0) -- the player has a label: "player" TODO: drop??
  end; 
end
</code></pre>
<a id="map"></a> 
The table of associations between labels (MUSE roles) and ComputerCraft computer IDs established for the session is isolated by exporting a function that returns an iterator for the elements of the table.
<pre><code class="language-lua">
---@diagnostic disable-next-line: redundant-return-value
function dds.map() return pairs(IDs) end --:: dds.map() -> Iterator from Muse roles to ComputerCraft IDs_ -> <code>():</code>, <code>{:}, </code>nil`

return {dds = dds}

  </body> 
</html>

