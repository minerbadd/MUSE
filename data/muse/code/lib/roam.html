<!DOCTYPE html>
 <html>
<head>
<link href="https://minerbadd.github.io/CodeMark/assets/prism.css" rel="stylesheet" />
<link href="https://minerbadd.github.io/CodeMark/assets/downmark.css" rel="stylesheet" />
</head>
<body>
<script src="https://minerbadd.github.io/CodeMark/assets/prism.js"></script>

---@diagnostic disable: duplicate-set-field
<h2>Commands <code>go</code>, <code>to</code>, <code>trace</code>, <code>come</code> <code>tail</code> : lib/roam</h2>
<pre><code class="language-markdown">
--:! {roam: [":"]: ():} <- <b>Command Line Library for Turtle Movement</b> -> muse/docs/lib/roam.md  
--:| roam: <i>Server (turtle) side</i> <code>come</code> <i>and</i> <code>tail</code>, <i>chained</i> <code>go</code> <i>commands, motion</i> <code>to</code> <i>and</i> <code>trace</code>. -> roam
</code></pre>
There are a few new things. Firstly, the <code>roam</code> library is a <code>CLL</code>, a command line library, a supporting library for a CLI, command line interface. Hints are provided as <a href="core.html#UI" target="_blank"> shell completions </a> for CLI command entry to indicate what's expected for the command. These are accumulated in the <code>roam.hints</code> table, each hint provided near the function that supports a particular command. The idea is that as function definitions change during the evolution of a module, the CLI hint is more likely to get an appropriate update if it's near the supporting function.
<p>
With that said, the introduction should look like something you've seen before. We'll come to <code>_G.Muse.permutations</code> shortly.
<pre><code class="language-lua">
local roams = require("signs.roam"); roams.roam = {}; local roam = roams.roam; roam.hints = {} ---@module "signs.roam" 

local cores = require("core"); local core = cores.core ---@module "signs.core"
local motion = require("motion"); local move = motion.move ---@module "signs.motion"
local turtles = require("turtle"); local turtle = turtles.turtle ---@module "signs.turtle"
local places = require("places") local place, moves = places.place, places.moves ---@module "signs.places"

local axes = _G.Muse.permutations
</code></pre>
<a id="come"></a>
<h3>Directed Movement: <code>come</code> (and <code>tail</code>) to follow the player</h3>
After the usual library introduction above, there are functions supporting attempted movement toward a target trying all the permutations in turn along the x, y, and z axes to deal with any blockages. Attempted movements return a message indicating eventual success or failure. There's a global reference, <code>_G.Muse.permutations</code> set up in <a href="_start.html" target="_blank"> startup</a> for the game. It establishes the first set of axes to move along to get to a place.
<pre><code class="language-lua">
-- :# <b>Movement along each axis in turn. The sequence is set by the permutation</b>.
-- :# {"y", "z", "x"} -> z x y, x z y, x y z, y x z, z y x, y z x

local function toAxes(change, currentAxes, targetAxes) 
  local targets = {}; -- set up to try <code>move.to</code>; movement along each axis established by <code>permuting</code>
  for i in ipairs(change) do targets[change[i]] =  targetAxes[change[i]] 
    for _, axis in ipairs(change) do currentAxes[axis] = targets[axis] or currentAxes[axis] end
    core.status(5, "roam axes", change, currentAxes, targetAxes) -- protected call: <code>move.to</code> throws errors
    local ok, _, recovery = core.pass(pcall(move.to, {currentAxes.x, currentAxes.y, currentAxes.z, "north"}))
    if not ok then local _, code = table.unpack(recovery) 
      if code == "blocked" then turtle.blocking(); return end -- update mock turtle block status for testing
    end -- <code>move.to</code> failed, return <code>nil</code> to get another permutation; 
  end; return "done" -- success! (<code>move.to</code> worked for movement along each axis)
end

local function permuting(currentAxes, targetAxes) 
  local code; local x, y, z = move.get()  -- dead reckoning 
  for change in core.permute(axes) do code = toAxes(change, currentAxes, targetAxes); 
    if code == "done" then return "done" end -- successful movement; else try another permutation
  end -- tried all permutations but not at target; if any movement, try permutations from new position
  local mx, my, mz = move.get(); local distance = math.abs(x - mx) + math.abs(y - my) + math.abs(z - mz)
  core.status(3, "roam retry", distance, mx, my, mz) -- if no movement, just return failure, else recur
  return distance == 0 and code or permuting({x = mx, y = my, z = mz}, targetAxes)
end
</code></pre>
That was the hard part. The rest is straight forward.
<pre><code class="language-lua">
local function moveHere(tx, ty, tz, ttx, tty, ttz)
  return permuting({x = tx, y = ty, z = tz}, {x = ttx, y= tty, z = ttz}) -- currentAxes, targetAxes
end

local function fueling(tx, ty, tz, ttx, tty, ttz)
  local distance = math.abs(ttx-tx) + math.abs(tty-ty) + math.abs(ttz-tz) 
  local fuel = turtle.fuel(); local fueled = fuel - distance
  return fueled > 0, "fuel "..fueled.." for "..distance.." blocks to {"..ttx..","..tty..","..ttz.."}"
end

local function moving(tx, ty, tz, ttx, tty, ttz, op) -- <code>op</code> is <code>roam.come</code> or <code>to</code>
  local fuelOK, message = fueling(tx, ty, tz, ttx, tty, ttz); if not fuelOK then return "empty", message end
  local code, at = moveHere(tx, ty, tz, ttx, tty, ttz), move.ats()
  return code == "done" and "at "..at.." "..message or op..code.." at "..at -- failure report
end
</code></pre>
And now for something not so different. Here's the actual function for the command.
<pre><code class="language-lua">
--:: roam.come(:xyz:) -> <i>Server (turtle) side: move turtle (close to) player's GPS</i> <code>xyz</code> <i>from</i> <code>remote.come. -> </code>":" &:`
function roam.come(xyz) -- <b>needs GPS for {xyz} in game</b>, lib/remote RPC "come" dispatched by lib/net 
  local px, py, pz = table.unpack(xyz); local txyz = assert(place.xyzf(), "roam come: no turtle situation??")
  local tx, ty, tz = table.unpack(txyz); local dx, dz = px - tx, pz - tz -- x and z distance to turtle (t) from player's px, pz
  local ttx = px - 1 * (dx == 0 and 0 or math.abs(dx)/dx) -- turtle target 1 away from player along travel vector
  local ttz = pz - 1 * (dz == 0 and 0 or math.abs(dz)/dz) -- turtle target 1 away from player along travel vector
  local tty = py - 1; return moving(tx, ty, tz, ttx, tty, ttz, "rome.come ")
end 

roam.tail = roam.come; roam.hints["tail"] = {["?rate"] = {}} -- separate but equal, allow for future discriminate action 
--:: roam.tail(:xyz:) -> <i>Server side: move turtle (close to) player's GPS</i> <code>xyz</code> (<i>from</i> <code>remote.tail)</code> -> <code>":" &:</code>
</code></pre>
<a id="to"></a> 
<h3>Coordinate Movement: <code>to</code> a <code>place</code> or a `position</h3>
The <code>to</code> function is used in order to move to a <code>position</code> (with <code>move.to</code>) or a <code>place</code> (with <code>moves.to</code>). Tries all permutations using the common routines above.
<p>
There's also that mysterious stuff around <code>roam.hints</code>. As said, the stuff populates a table used by <a href="core.html#UI" target = "_blank"><code>core.completion</code> </a> to provide shell completions in ComputerCraft's CraftOS in the format that it expects.
<pre><code class="language-lua">
local function to(arguments) 
  --:- to place | x y z face?-> <i>To named place or position and face. Retry permutation for different first direction.</i> 
  local _, x, y, z, facing = table.unpack(arguments); local tx, ty, tz = table.unpack(move.at()) -- from
  local toPlace = tonumber(x) and {tonumber(x), tonumber(y), tonumber(z), facing or "south"} or place.xyzf(x) -- x: named place
  assert(toPlace, "roam.to: Can't go to a place unknown "..x)
  local ttx, tty, ttz = core.xyzf(toPlace); return moving(tx, ty, tz, ttx, tty, ttz, "rome.to ") -- <b>do it!</b>
end; roam.hints["to"] = {["?name | ?x y z "] = {["??face"] = {}}}
</code></pre>
<a id="trace"></a>
<h3>Tracing A Trail</h3>
<pre><code class="language-lua">
local function trace(arguments) 
  --:- trace trailname ->  <i>Move turtle along traced situations in named trail from one end of trail to the other.</i>
  local _, trailname = table.unpack(arguments) -- first argument is command
  local moveOK, code, index = core.pass(pcall(moves.along, trailname))
  if moveOK then return "trace "..index.." to "..move.ats() end -- no permutation retry on failure
  return "roam.trace: "..trailname.." failed because "..code.." with "..index.." remaining at "..move.ats() 
end roam.hints["trace"] = {["?trail"] = {}} 
</code></pre>
<a id="go"></a>
<h3>Chained Movement: the <code>go</code> command</h3>
The <code>go</code> command is implemented with a relatively thin envelope around the primitive (no permutations retry) operations. Mostly the envelope deals with parsing, dispatch, and errors. This is a common pattern allowing easier modification of the user interface (UI) as needed . The hard work, that done by the underlying libraries, is unaffected when the UI needs to be modified. 
<p>
The command is provided with a tiny language to chain together where to <code>go</code>.
<pre><code class="language-lua">
-- <b>Chained commands</b>
local movements = {
  n = function(count) return move.north(tonumber(count)) end, 
  e = function(count) return move.east(tonumber(count)) end,
  s = function(count) return move.south(tonumber(count)) end,
  w = function(count) return move.west(tonumber(count)) end,
   r = function(count) return move.right(tonumber(count)) end,
  l = function(count) return move.left(tonumber(count)) end,
  f = function(count) return move.forward(tonumber(count)) end,
  b = function(count) return move.back(tonumber(count)) end,
  u = function(count) return move.up(tonumber(count)) end,
  d = function(count) return move.down(tonumber(count)) end,
} 

local function doChain(command) -- attempt to do one command table entry from chain 
  local letter = command[1]; local movement = movements[letter]-- command letter for dispatch
  if not movement then error("roam.doChain: Invalid operation: "..core.string(command)) end
  return movement(table.unpack(command, 2)) -- return the result of the command 
end

local function chain(i, line, commands) -- make command table { { ":", [#:] }... }  for <code>doChain</code>
  if i > #line then return commands end -- <code>line</code> is table of letters followed by its corresponding number if any 
  local letter, count = string.sub(line[i], 1, 1), tonumber(line[i + 1]) -- letter number pattern?
  if type(count) == "number" then table.insert(commands, {letter, count}); return chain(i + 2, line, commands) end -- yep
  table.insert(commands, {letter}); return chain(i + 1, line, commands) -- nope, this one's just letter; try next 
end

local function go(line) -- returns the result from last chain command attempted
  --:# Movements are <code>r[ight], l[eft], f[orward], b[ack], u[p], d[own], n[orth], e[ast], s[outh], w[est]</code>.
  --:- go <i>(first letter of) directions followed by optional counts, e.g. <code>r 10 u east 3 u 4 d n</code>.</i> -> <i>Chained movement.</i>
  local commandOK, code; local commands = chain(2, line, {}); -- line[1] is  "go"
  for _, command in ipairs(commands) do commandOK, code  = core.pass(pcall(doChain, command))
    if not commandOK then 
      error("roam.go: Failed "..core.string(command).." in "..core.string(line).." because "..code.." at "..move.ats()) 
    end
  end; return "roamed to "..move.ats()
end; roam.hints["go"] = {["?chain n e s w u p r l f b"] = {}}
</code></pre>
<a id="op"></a> 
<h3>Dispatch and Done</h3>
Just a simple dispatch, some error handling, and our work here is done.  As mentioned, this is the first CLL we've run across. 
The design pattern is worth looking at. All the interesting stuff is done here in the library so that the CLI itself, the command program, is dead simple. Look at what goes before to see how.
<pre><code class="language-lua">
local ops = {go = go, to = to, trace = trace, } 

local function here() -- are we actually here? (defensive programming, checking dead reckoning against GPS)
  local gx, gy, gz, _, ok = move.where(); if not ok then return end -- can't check without GPS
  local ax, ay, az = table.unpack(move.at()); if not (gx == ax and gy == ay and gz == az) then error("roam.here: Lost!") end
  return core.ats()
end

function roam.op(arguments) --:: roam.op(arguments: ":"[]) -> <i>Move turtle:</i> -> <code>":" &:</code>
  local from = here() -- as a defensive move, check dead reckoning
  local roamOK, message = core.pass(pcall(ops[arguments[1]], arguments))
  return roamOK and message.." from "..from or "roam failed "..arguments[1].." in "..core.string(arguments).." because "..message
end

return {roam = roam}
</code></pre>
Look at <a href="../tests/roam.html" target = "_blank"> <code>tests/roam</code> </a> and <a href="check.html" target = "_blank"> <code>lib/check</code></a>` to see how testing works for this module. Return to <a href="../../MiningMUSE.html#task"> MiningMUSE</a> to continue the exploration.
<p>
  </body> 
</html>

