<!DOCTYPE html>
 <html>
<head>
<link href="https://minerbadd.github.io/CodeMark/assets/prism.css" rel="stylesheet" />
<link href="https://minerbadd.github.io/CodeMark/assets/downmark.css" rel="stylesheet" />
</head>
<body>
<script src="https://minerbadd.github.io/CodeMark/assets/prism.js"></script>

<h2>Test: <code>tests/map</code> for <code>place</code> Persistence and Command</h2>
<pre><code class="language-markdown">
--:? muse/docs/tests/map.txt <- <b>Test <code>lib/map</code></b> -> muse/docs/tests/map.md 
--:# Test 
</code></pre>
<pre><code class="language-lua">
local check = require("check").check --:# Set configuration globals for tests by loading <code>lib/check</code>

local cores = require("core"); local core = cores.core ---@module "signs.core" 
local motion = require("motion"); local move = motion.move ---@module "signs.motion"
local places = require("places"); local place = places.place ---@module "signs.place"
local turtles = require("turtle"); local turtle = turtles.turtle ---@module "signs.turtle" -- just for blocking
local maps = require("map"); local map = maps.map ---@module "signs.map"

local regression = ... --:# Bind <code>regression</code> parameter <code>true</code> from call by <code>check.regression</code> in <code>lib/check</code>; otherwise <code>false</code>
core.log.level(regression and 0 or 3) --:# Set log level default. Set lower to report less, higher to report more

local testName = arg[0]:match("(%w-)%.%w-$") --:# Bind <code>testName</code> as the last word (without extension) in the execution path
local text = "Beginning "..testName..".lua test at "..move.ats()

--:# <code>turtle.blocking false</code>; <code>place.site TM</code>; <code>maps/TM.map</code>; <code>charts</code>; <code>core.setComputerLabel("tester")</code>
turtle.blocking(false); place.site("TM")

local test = check.open(testName, text, regression) --:# Create the test object for this test

local path = _G.Muse.path.."tests/"map.map(path.."maps/TM.map"); map.charts(path.."charts/")
core.log.level(3); core.setComputerLabel("tester")

--:# <b>Check turtle dance for facing witout dancing</b>
test.part("test setup", map.op, {"test", "test0", "label0", "199", "66", "262", "east"})
test.part("move to 10, 20, 30, east", move.where, 10, 20, 30, "east")
-- face (dx, dz, ew, we, ns, sn) -- face(dx, dz, "east", "west", "south", "north") -> 
test.part("facing north", map.testFacing, 0, -10, {"east", "west", "south", "north"})

--:# <b>Populate map</b>
test.part("fix 10, 20, 30, east", place.fix, {10, 20, 30,"east"})
test.part("point test1", map.op {"point", "test1", "label1"})
test.part("fix 10, 20 40, east", place.fix, {10, 20, 40,"east"})
test.part("point test2", map.op, {"point","test2", "label2"})
-- test.part("test rome", map.op, {"test", "rome", "home", "15", "25", "35", "east"})
test.part("test test3", map.op {"test", "test3", "label3", "10", "20", "30", "east"})

--:# <b>Look for what's near</b>
test.part("near", map.op, {"near"})
test.part("near 10", map.op, {"near", "10"}) -- span as placeName
test.part("near test1", map.op, {"near", "test1"})
test.part("near test1 10", map.op, {"near", "test1", "10"})

--:# <b>Look at where</b>
test.part("where nil, nil, 10, 20, 20", map.op, {"where", nil, nil, 10, 20, 20})
test.part("where 2, nil, 10, 20, 20", map.op, {"where", 2, nil, 10, 20, 20})
test.part("where nil, nil, 15, 20, 25", map.op, {"where", nil, nil, 15, 20, 25})
test.part("where test1, nil, 15, 20, 25", map.op, {"where","test1", nil, 15, 20, 25})
test.part("where test1, 2, 15, 20, 25", map.op, {"where", "test1", "2", "15", "20", "25"})
test.part("where nil, nil, 10, 20, 30", map.op, {"where", nil, nil, "10", "20", "20"})
test.part("where, 2, nil, 10, 20, 20", map.op, {"where", 2, nil, 10, 20, 20})
test.part("where, nil, nil, 15, 20, 25", map.op, {"where", nil, nil, 15, 20, 25})
test.part("where,test1, nil, 15, 20, 25", map.op, {"where","test1", nil, 15, 20, 25})
test.part("where, test1, 2, 15, 20, 25", map.op, {"where", "test1", "2", "15", "20", "25"})

--:# <b>Check range and view</b>
test.part("range", map.op, {"range", "tests", "range", "test1", "test2", "fields", "trees"})
test.part("view", map.op, {"view", "tests"}); 

--:# <b>Test maps for trails</b>
move.set(100, 150, 200, "west"); move.to({100, 150, 200,"west"}); 
test.part("point trail20", map.op, {"point", "trail20", "test20", "head20"})
move.set(100, 150, 200, "west"); move.to({100, 160, 210, "west"})
move.to({110, 170, 220, "east"}); move.to({120, 170, 220, "north"})
test.part("trail2021", map.op, {"trail", "tail21", "trail2021"})

--:# <b>View trails</b>
test.part("view trail20", map.op, {"view", "trail20"}) -- name, label, features, situations
test.part("view head20", map.op, {"view", "head20"}) 
test.part("view tail21", map.op, {"view", "tail21"})

--:# <b>Test borders</b>
-- map.borders({range}) -> <i>Get range</i> -> <code>{:borders}, {:features}, {:xyzFirst}, {:xyzSecond}</code>
test.part("borders", map.borders, "trail20") 

--:# <b>Test features</b>
-- map.put(name: ":", key: ":", [::value]) -> <i>Set feature, cast as Muse Update if named place.</i> ->  <code>false | (key: ":", ::value) & !</code>
test.part("map.put trueKey", map.put, "trail20", "trueKey")
test.part("map.put textKey", map.put, "trail20", "textKey", "theText")
test.part("map.put tableKey", map.put, "trail20", "tableKey", {1, 2, 3})

-- map.get(name: ":", key: ":") -> <i>Get feature value for key if named place.</i> -> <code>::value | false</code>
test.part("map.get trueKey", map.get, "trail20", "trueKey")
test.part("map.get textKey", map.get, "trail20", "textKey") 
test.part("map.get tableKey", map.get, "trail20", "tableKey")

test.part("map.get trail20", map.get, "trail20", "unknown")
test.part("view trail20", map.op, {"view", "trail20"})
  
--:# <b>Try erase</b>
-- erase name -> <i>Remove named place and broadcast Muse eXcise (MX) to units.</i> 
test.part("erase trail20", map.op, {"erase", "trail20"})
test.part("view trail20", map.op, {"view", "trail20"})

--:# <b>Test store operation (reads and writes map</b>
test.part("store", map.op, {"store", "happyplace"})
-- check read? 
-- remove site file?
-- test join?

-- test update

--:# <b>Check chart</b>
test.part("chart", map.op, {"chart", "TX", "fancy echo", {charted = "table"}, "something else"})

--:# Close test object, report completion if we got here without errors
test.close("Test "..testName.." complete") 

  </body> 
</html>

