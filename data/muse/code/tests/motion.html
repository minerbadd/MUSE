<!DOCTYPE html>
 <html>
<head>
<link href="https://minerbadd.github.io/CodeMark/assets/prism.css" rel="stylesheet" />
<link href="https://minerbadd.github.io/CodeMark/assets/downmark.css" rel="stylesheet" />
</head>
<body>
<script src="https://minerbadd.github.io/CodeMark/assets/prism.js"></script>

<h2>Test: <code>tests/motion</code> for <code>move</code> and <code>step</code> interfaces of <code>lib/motion</code></h2>
<p>
So here we are, exploring our first MUSE test. It is meant to fit into the MUSE regression jig implemented by <code>lib/check</code>. It's neither a library nor a ComputerCraft program. It is an executable though. Just execute it as you would any Lua program. 
<p>
The HELP file mark above specifies that there will be a help text file and a summary markdown document. The markdown document will be processed to produce an html file describing the test using the HEAD comments in the test.
<p>
<pre><code class="language-lua">
--:? muse/docs/tests/motion.txt <- <b>Test <code>lib/motion</code></b> -> muse/docs/tests/motion.md 
local check = require("check").check --:# Set configuration globals for tests by loading <code>lib/check</code>

local cores = require("core"); local core = cores.core ---@module "signs.core" 
local motion = require("motion"); local move, step = motion.move, motion.step ---@module "signs.motion"
local turtles = require("mock"); local turtle = turtles.turtle ---@module "signs.mock"


local regression = ... --:# Bind <code>regression</code> parameter <code>true</code> from call by <code>check.regression</code> in <code>lib/check</code>; otherwise <code>nil</code>
core.log.level(regression and 0 or 5) --:# Set log level default. Set lower to report less, higher to report more

local testName = arg[0]:match("(%w-)%.%w-$") --:# Bind <code>testName</code> as the last word (without extension) in the execution path
local text = "Beginning "..testName..".lua test at "..move.ats()
local test = check.open(testName, text, regression) --:# Create the test object for this test

turtle.blocking(false) -- <code>lib/motion</code> loaded <code>lib/mock</code>

--:# <b>Test simple <code>move</code> motions</b>
test.part(1, "east", move.east())
test.part(2, "forward 10", move.forward(10))
test.part(3, "back 10", move.back(10))
test.part(4, "right 10", move.right(10))
test.part(5, "left 10", move.left(10))
test.part(6, "east 10", move.east(10))
test.part(7, "north 10", move.north(10))
test.part(8, "south 10", move.south(10))
test.part(9, "west 10", move.west(10))
test.part(10, "back", move.back())
test.part(11, "east", move.east())
test.part(12, "north 0", move.north(0))
test.part(13, "south 0", move.south(0))
test.part(14, "up 10", move.up(10))
test.part(15, "down 10", move.down(10))

turtle.blocking(true) -- blocked in lib/motion xyzMotion
test.part(16, "forward 10 blocked", move.forward(10))
turtle.blocking(false)

--:# <b>Test compound operations</b>
test.part(17, "to 100 150 200 west", move.to({100, 150, 200,"west"}))

--:# <b>Test simple <code>step</code> operations</b>
local east = 18; for code, remaining, ats in step.east(3) do east = east + 0.1
  test.part(east, "step.east(3)", code, remaining, ats)
end

local south = 19; for code, remaining, ats in step.south(3) do south = south + 0.1
  test.part(south, "step.south(3)", code, remaining, ats)
end

local west = 20; for code, remaining, ats in step.west(3) do west = west + 0.1
  test.part(20, "step.west(3)", code, remaining, ats)
end

local north = 21; for code, remaining, ats in step.north(3) do north = north + 0.1
  test.part(north, "step.north(3)", code, remaining, ats)
end

--:# Test <code>step</code> iterator
local more = step.forward(3)
test.part(22, "steps 1 forward 3", more(), move.ats())
test.part(23, "steps 2 forward 3", more(), move.ats())
test.part(24, "steps 3 forward 3", more(), move.ats())
test.part(25, "steps 4 forward 3", more(), move.ats()) 

--:# Check "step.to 105 156 207 west")
local stepping = 26; for code, remaining, at, direction, all in step.to({105, 156, 207}) do 
  stepping = stepping + 0.001; test.part(stepping, code, remaining, core.string(at), direction, all)
end; test.part(27, "stepped to", core.ats())

--:# Check tracking
test.part(28, "start tracking", move.situationsBegin())
move.track(true); move.forward(5); move.up(5); move.back(5); move.down(5)
test.part(29, "end tracking", move.situationsEnd())
move.track(false)



--:# Close test object, report completion if we got here without errors
test.close("Test "..testName.." complete") 

  </body> 
</html>

