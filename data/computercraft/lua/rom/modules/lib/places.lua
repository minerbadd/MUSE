---@diagnostic disable: duplicate-set-field
--[[
## Serialization, Feature Lists, and Using Iterators: `lib/places` to Name Positions
```md
--:! {place: [":"]: ():, moves: [":"]: ():, steps: [":"]: ():} <- **Places Functions Libraries** -> muse/docs/lib/places.md  
--:| places: _Naming places at MUSE coordinates, moving there, stepping there for operations._ -> places, place, moves, steps
--:+ place: **Name places (points, trails, ranges); serialize and load serializations for disk and network operations.**  
--:+ moves: **Move turtles to named places or along named trails.** 
--:+ steps: **Iterator to move block by block to named places or along named trails.**
```
As might be guessed, this module deals with the idea of a `place`, a data stucture representing position in the Minecraft coordinate system. With the libraries generated by this module, we can note the position of a turtle or the player's pocket computer, give a name and a descriptive label to that position (creating a `place`), recall that place by name, forget about a place, find distances between places, and find the places near (and nearest) a turtle or other places. We can `move` (and `step`) a turtle to such places by name. The `lib/place` module also introduces the idea of a `trail`, a kind of `place` that is a sequence of turtle positions built on `lib/motion` tracking. Turtles can be moved (and stepped) along such trails. The idea of _place_ is extended further to include a `range`. A _range_ is a pair of positions defining a volume. It's a design decision to lump these three ideas into the concept of a named `place`. The thought is that that concept was what was important. Details of what exactly was in that place was just about the `situations` associated with a _place_.

The `place` module supports the notion of a `site`, a set of places local to some geography and associated with a set of, so called `landed` turtles. There can be a number of sites in a Minecraft world. 

As we've indicated, these libraries depend on `lib/motion`. Keeping its <a href="../../docs/lib/motion.html" target="_blank"> exports </a> in mind might be helpful in understanding this module.

The implementations of these libraries are fairly straight forward. There are fewer ways to go wrong and fewer ways to specify what's to be done. So thankfully, there's not much new beyond what's been discussed for <a href="motion.html" target="_blank"> `lib/motion` </a>. There won't be much to discuss about the code. One thing to note though is that the `place` type (in serialized form) will be sent around the network and persist on disk storage. Because of that there's value in keeping it both simple and flexible. If all of this were in the real world, changing it if it weren't simple and flexible would be difficult to manage. There'd be all those (now incompatible) `place` data structures hanging about on disks spread all over the network. This motivates the incorporation of `features`, which we'll come to in a bit.

All that said, here's the introduction and utilities for the module. As in `lib/motion`, we provide for type checking in the module by LLS by loading `signs.places` and referencing what's loaded.
```Lua
--]]
local placings = require("signs.places"); placings.places, placings.place, placings.moves, placings.steps = {}, {}, {}, {}
local _, place, moves, steps = placings.places, placings.place, placings.moves, placings.steps ---@module "signs.places"

local cores = require("core"); local core = cores.core ---@module "signs.core"
local motion = require("motion"); local move, step = motion.move, motion.step ---@module "signs.motion"

_G.Muse.places = _G.Muse.places or {}; local placePlaces = _G.Muse.places -- **global across programs in session, not persistent**

--:# **Type definitions that will be serialized for network transport and disk storage**
--:> place: _A point, trail, or range_ -> `[name: ":", label: ":", :situations:, :features:]`
--:> features: _Dictionary of string key, any value pairs_ -> `[key: ":"]: any`

--:# **Utilities for places (points, trails, and ranges)**
function place.reset() placePlaces = {} end
--:: place.reset() -> _Resets places to the empty table._ -> `nil`
function place.count() return #placePlaces end
--:: place.count() -> _Returns number of places._ -> `#:`
function place.site(value) if value then _G.Muse.site = value end; return _G.Muse.site end -- isolate global
--:: place.site(value: ":"?) -> _Set or return local `site` (isolates global)._ -> `":"`
function place.qualify(name) return name and (string.find(name, "%.") and name or place.site().."."..name) end
--:: place.qualify(name: ":") -> _Return already sited name, otherwise prepend site to name_ -> `sitedName: ":"`
function place.distance(a,b)  
--:: place.distance(a: xyzf, b: xyzf) -> _Manhattan: abs(delta x) + abs(delta y) + abs(delta z)._ -> `distance: #:`
  local ax, ay, az = table.unpack(a); local bx, by, bz = table.unpack(b)
  return math.abs(ax - bx) + math.abs(ay - by) + math.abs(az - bz)
end

local function xyzfSituation(situation, index) return move.at(situation), index end  
-- : xyzfSituation(:situation:, index: #:) -> _Faced position, default current situation_ -> `xyzf, index: #:`
--[[
```
<a id="match"></a>
The following is an unassuming little function, `place.match`, right at the heart of `places`. It finds a `place`. The places in the `placePlaces` table shadow the global `_G.Muse.places`. Note that the lookup is of a `site` qualified name. A qualified name is a place name specific to a site. 

After `place.match` is a function, `place.xyzf`, to report the coordinates and orientations associated with a `place`. There may be several as needed for a `trail` or a `range` named by the `place`.
```Lua
--]]
function place.match(name) 
  --:: place.match(name: ":") -> _Lookup place qualified by site, return_ `nil` _if not found._ -> `order: #:?, place: place?`
  local qualified = place.qualify(name); for order, placed in ipairs(placePlaces) do 
    if qualified == table.unpack(placed) then return order, placed end 
  end
end

function place.xyzf(target, index) -- target place (with index for situations) or current situation position 
  --:: place.xyzf(name: ":"?, index: #:?) -> _Looks up index in name [defaults to current situation]._ -> `xyzf?, order: #:?`
  if not target then return xyzfSituation() end -- current position of this turtle
  local order, placed = place.match(target); if not (order and placed) then return nil end
  local _, _, situations = table.unpack(placed); -- trails and ranges have mre than one
  index = index or 1; assert(index <= #situations, "places.xyzf: has less than "..index.." situations")
  return xyzfSituation(situations[index], order) -- place situation 
end
--[[
```
<a id="name"></a> 
The following function, `place.name`, is the complement to `place.match`. Here's where places get remembered and the global `_G.Muse.places` gets changed. In the code below there are two concepts worth thinking about: serialization and what we're calling _features_. Features are just a dictionary included with a `place` to (flexibly) specify properties associated with the `place` by other libraries. This sort of thing tends to help in providing for a maintainable evolution of a data structure spread across a network. _Serialization_ will be discussed in the context of 
<a href="../../MiningMUSE.html#persistence" target="_blank"> persistence </a> 
important to clients of `lib/places`. Follow the link if you want to explore it now.
```Lua
--]]
function place.name(name, label, supplied, features) -- newSituation(s) is from `place.trail` or `map.place` 
  --:: place.name(name: ":", label: ":", supplied: situation?, :features:??) -> _Make or update place._ -> `":", #:`
  --:+ _Include current situation or optionally supplied situation in places. Optionally update features with key = value._
  --:+ _Return order of situation in global places and the serialized situation including its features._
  local situation = supplied or move.situation(); features = features or {} -- clone to capture current situation
  local situations = #situation > 0 and situation or {situation} -- must be an array

  local order, matched = place.match(name); -- look for pre-existing
  local matching = matched or {"", "", {}, {}} -- initial structure for a place
  local _, _, _, matchedfeatures = table.unpack(matching); -- pre-existing
  for key, value in pairs(features) do matchedfeatures[key] = value end -- overwrite or new

  local candidate = {place.qualify(name), label, situations, matchedfeatures} 
  local indexed = order or #placePlaces + 1; placePlaces[indexed] = candidate -- replace or new place
  core.report(4, "places", "name ", indexed, candidate)
  return core.serialize(candidate), indexed -- serialized for disk or net 
end
--[[
```
As mentioned, there may be a number of `situations` associated with a `place`. Here's how they get added. And how they all get forgotten (erased) locally at a turtle or other ComputerCraft computer.
```Lua
--]]
function place.add(name, situation)
--:: place.add(name: ":", :situation:) -> _Add situation to situations of an existing place._ -> `serialized: ":"?, order: #:?`
---@diagnostic disable-next-line: missing-return-value
  local order, matched = place.match(name); if not matched then return end
  local _, _, situations = table.unpack(matched); situations[#situations + 1] = situation
  return core.serialize(matched), order
end 

function place.erase(name) -- remove place if found
--::place.erase(name: ":") -> _Removes named place from array of places._ -> `#:, order: #:?`
--:+ _Return new length of places table and the (previous) order of the removed place._
  local order = place.match(name); if order then table.remove(placePlaces, order) end
  return #placePlaces, order -- leaves sparse array
end
--[[
```
<a id="where"></a> 
Implementing support for the "where" of things is straightforward. But look at `place.near` for a caution about the use of iterators.
```Lua
--]]
--:# **Answering "where?"**
local function placeSituation(name) -- situation for named place;
  local order, matched = place.match(name); if not order then return nil end
---@diagnostic disable-next-line: param-type-mismatch
  local _, label, situations = table.unpack(matched); return situations[1], label
end
--[[
```
<a id="near"></a>
The upvalues of iterators establish part of its execution context. It's tempting to reference them in a `for` loop. Doing so, resets them to their initial value, generally not what's desired. 
```Lua
--]]
function  place.near(span, reference) -- iterator: places in span distance of current situation|place or all places
--:: place.near(span: #:?, reference?:":"|[x:#:,y:#:,z:#:]) ->  -> (): `name: ":", label: ":", xyz, distance: #:, situations, serial: ":"`
--:+ _If both span and name (or a position) are specified, return places within a span of blocks of the named place (or position)._
--:+ _If only the span is specified, return places within a span of blocks of the current situation or player position._
--:+ _If neither is specified return each of the named places. In any case, iterator returns include serialized places._
  local situation = type(reference) == "string" and placeSituation(reference) or _G.Muse.situation
  local x, y, z = move.get(situation); local xyzReference = type(reference) == "table" and reference or {x, y, z}
  local order = 0; local count = #placePlaces;  -- upvalues for returned closure

  return function() -- the iterator; 
    -- **note:** `for order = 1, count do` .... **would reset** `order` **every time the closure is invoked**
    while order < count do order = order + 1
      local namePlace, labelPlace, situations = table.unpack(placePlaces[order])
      local positionPlace = situations[1].position; -- trails and ranges have more than one
      local xyzPlace = {positionPlace.x, positionPlace.y, positionPlace.z}
      local distance = place.distance(xyzPlace, xyzReference); 
      if not span or distance <= span then 
        return namePlace, labelPlace, xyzPlace, distance, situations, core.serialize(placePlaces[order]) 
      end
    end
  end -- end closure
end
--[[
```
<a id="nearby"></a>
The `place.nearby` function demonstrates some potentially useful techniques: 
</br>
</ul>
<li>The `cardinals` argument of `place.nearby` is supplied by a higher level library that uses `place.nearby`. Other libraries that use `place.nearby` don't generate such a function but still have need of the rest of what `place.nearby` produces. Providing a placeholder dummy function deals with the situation.</li>
<li>The arguments of `place.nearby` are both optional and of different types. Checking the types allows binding to default values for the missing arguments.</li>
<li>The explicit and calculated features of each named place are accessed through an iterator, `place.near`, discussed just previously, which isolates the underlying global.</li>
<li>The call of `table.sort` includes an <a href="https://en.wikipedia.org/wiki/Anonymous_function" target="_blank">
_anonymous function_</a> that specifies how the sort is to be done.</li>
</ul></br>
```Lua
--]]
function place.nearby(xyzf, cardinals) -- dummy function is supplied for missing cardinals argument
--:: place.nearby(:xyzf:?, :cardinals:) -> _Sorted_ -> `[distance: #:, name: ":", label: ":", cardinal: ":", :xyzf:]`
--:> cardinals: _Function to get one of the eight cardinal points of the compass_ -> (dx: #:, dz: #:): cardinal: ":"
--:+ _Nearest places to specified xyzf coordinates or current position (as default)._ 
--:+ _Returned table is sorted by distances and includes the name, label, and xyzf position of each place._
--:+ _If a `cardinals` function is supplied, the eight point cardinal direction is also included._
  local reference = type(xyzf) ~= "table" and move.at() or xyzf; local x,_,z = table.unpack(reference); 
  cardinals = type(xyzf) == "function" and xyzf or (cardinals or function(_, _) return "" end) -- dx, dz

  local namedPlaces = {}; for name, label, pxyz in place.near() do 
    local px, py, pz = table.unpack(pxyz); local distance = place.distance(pxyz, xyzf); 
    local position, cardinal = core.xyzf({core.round(px), core.round(py), core.round(pz)}), cardinals(px - x, pz - z)
    namedPlaces[#namedPlaces + 1] = {distance, name, label, cardinal, position}
  end; table.sort(namedPlaces, function(a,b) return a[1] < b[1] end) -- on `distance`

  return namedPlaces
end
--[[
```
<a id="trail"></a>
We've spoken about tracking when we looked at the implementation of <a href="motion.html#tracking" target="_blank">`lib/motion` </a>. Tracking is used to create a `trail`, a history of turtle movements that can be replayed forward or backwards and `moves` or `steps` a turtle along a trail.
```Lua 
--]]
--:# **Support for trails (names and labels for sequences of situations)**
function place.fix(xyzf, track) -- set position, possibly for trailhead if tracking
--:: place.fix(:xyzf:, track: ^:?) -> _Sets situation position, can start tracking for trail._ -> `xyzf` 
  assert(#xyzf == 3 or (#xyzf == 4 and type(xyzf[4] == "string")), "place.fix: bad arguments "..core.string(xyzf)) -- LLS miss
  move.set(table.unpack(xyzf)); move.tracking(track) -- enable tracking, set first situation in trail
  return xyzf
end

local function reverseTrail(situations) -- get trail from end back to head
  local reversed = {}; local index = #situations; for _, situation in ipairs(situations) do 
    reversed[index] = situation; index = index - 1 -- new table, no mutation of `situation`, so no clone
  end; return reversed
end

function place.trail(headName, tailName, label) -- places for trail end and head 
--:: place.trail(headName: ":", tailName: ":", label: ":") -> _Makes two places._ -> `headSerial: ":", tailSerial: ":", count: #:`
--:+ _Trail places share a label and represent trails from head to tail and tail to head; head set by_ `place.fix`.
  local situations = move.situations() -- deep copy the track produced by `lib/motion`
  assert(#situations > 0, "place trail: trail needs starting situation")
  local headString = place.name(headName, label, situations) -- head place and end place share a label
  local tailString = place.name(tailName, label, reverseTrail(situations))
  local _, count = move.tracking(false) -- return #situations in trail; clean up and disable tracking, 
  return headString, tailString, count
end

function place.track(name) -- return track elements of trail if trail exists
  --:: place.track(name: ":") -> _Returns trail_ -> `name: ":"?, label: ":"?, :situations:?`
  assert(name, "places: Need a name for trail")
  local order, matched = place.match(name); if not order then return nil end
---@diagnostic disable-next-line: redundant-return-value, param-type-mismatch
  return table.unpack(matched) -- name, label, situations
end
--[[
```
Mostly just placing a naming layer on `move` and `step` but look at how iterators are handled in `steps.along`.
```Lua
--]]
--:# **Moving and stepping for known places: to points or along trails**
function moves.along(name) -- move along trail 
--:: moves.along(name: ":") -> _Move from first to second situation of place._ -> `code: ":", remaining: #:, xyzf: ":" &!recovery`
--:+ _If the named place is the head of a trail, go from there to its tail. If it's a tail of a trail, go to its head._
  local _, _, situations = place.track(name); -- existing trail?
  if not situations then error("moves.along: can't find "..name) end
  if #situations == 0 then return "done", 0, move.ats() end -- note `{} ~= nil` however `#{} == 0`
  for _, situation in ipairs(situations) do local xyzf = xyzfSituation(situation); move.to(xyzf)
  end; return "done", 0, move.ats()
end

function steps.along(name) -- step from each situation to the next beginning with the current situation
--:: steps.along(name: ":") -> _Iterator: first to next situation of place._ -> `(): code: ":", remaining: #:, xyzf: ":" &!recovery`
--:+ _If the named place is the head of a trail, step from there to its tail. If it's a tail of a trail, step to its head._
  local _, _, situations = place.track(name); local iterators = {}; 
  local clonedSituations = core.clone(situations); -- deep copy because there's a mutation coming next
  table.insert(clonedSituations, 1, move.situation()) -- push a copy of the current situation onto the cloned table

  for index = 2, #clonedSituations do 
    local current, prior = clonedSituations[index], clonedSituations[index - 1]
    local xyzf = xyzfSituation(current) -- get xyzf from each what will be "current" situation 
    iterators[index-1] = step.to(xyzf, prior); 
  end; -- and now the iterator of iterators

  return function()
    for index, iterator in ipairs(iterators) do -- exhausted iterators return `nil`
      local code, remaining, ats, direction, distance = iterator() -- iterator remembers remaining work
      if code then return code, remaining, ats, direction, distance, index end
    end -- this iterator complete
  end -- returns nil when all iterators completed
end

local function checkTarget(target) -- separated out from `moves.to` for clarity
  assert(target, "places: Need moves target to go there")
  local xyzfTarget = assert(place.xyzf(target), "places: Place to move to not found: "..target)
  return xyzfTarget
end

function moves.to(target, first) local xyzfTarget = checkTarget(target); return move.to(xyzfTarget, first) end
--:: moves.to(target: ":", first: ":"?) -> _Move to target, first along direction._ -> `code: ":", remaining: #:, xyzf: ":" &!recovery`

function steps.to(target) assert(target, "places: Need target to step there")
  --:: steps.to(target: ":") -> _Step (iterator) to target place._ -> `(): code: ":", remaining: #:, xyzf: ":" &!recovery`
  local xyzf = assert(place.xyzf(target), "places: Place to step to not found: "..target)
  return step.to(xyzf)
end
--[[
```
<a id="tables"></a> 
The module exports three tables: one to deal with names, one to deal with movement directed by those names, and one to deal with stepping through such movement. And that's it for the second of the MUSE foundation libraries. Look at <a href="../tests/places.html" target = "_blank"> `tests/places </a>  and <a href="check.html" target = "_blank"> `lib/check`</a>` to see how testing works for this module. And then head back to <a href="../../MiningMUSE.html#Chapter3"> _MiningMUSE_</a> for a discussion of persistence, distributed state, and much, much more!
```Lua
--]]
return {place = place, moves = moves, steps = steps}