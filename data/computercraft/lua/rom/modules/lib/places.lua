--[[
## Serialization, Feature Lists, and Using Iterators: `lib/places.lua` to Name Positions
```md
--:! {place: []: (:), moves: []: (:), steps: []: (:) } <- **Places Functions Library** -> muse/docs/lib/places.md  
--:| places: _Naming places at MUSE coordinates, moving there, stepping there for operations._ -> places, place, moves, steps
--:+ place: **Name places (points, trails, ranges); serialize and load serializations for disk and network operations.**  
--:+ moves: **Move turtles to named places or along named trails.** 
--:+ steps: **Iterator to move block by block to named places or along named trails.**
```
As might be guessed, this module deals with the idea of `places`, positions in the Minecraft coordinate system. With the libraries generated by this module, we can note the position of a turtle or the player's pocket computer, give a name and a descriptive label to that position (creating a `place`), recall that position by name, forget about a position, find distances between positions, and find the positions near (and nearest) a turtle or other places. We can `move` (and `step`) a turtle to such places by name. The `lib/place` library also introduces `trails`, sequences of turtle positions built on `lib/motion` tracking. Turtles can be moved (and stepped) along such trails. The `place` library supports the notion of `sites`, a set of places local to some geography. There can be a number of sites in a Minecraft world.

As we've indicated, these libraries depends on `lib/motion`. Keeping its <a href="../../docs/lib/motion.html" target="_blank"> exports </a> in mind might be helpful in understanding this library.

The implementations of these libraries are fairly straight forward. Thankfully, there's not much new beyond what's been discussed for <a href="motion.html" target="_blank"> `lib/motion` </a> so there won't be many discussions of the code. One thing to note is that the `place` type (in serialized form) will be sent around the network and persist on disk storage. Because of that there's value in keeping it both simple and flexible. (If all of this were in the real world, changing it would be difficult to manage.) 

All that said, here's the introduction and utilities for the module.
```Lua
--]]

local place, moves, steps  = {}, {}, {} ---@module "signs.places"

package.path = _G.Muse.package
local cores = require("core"); local core = cores.core ---@module "signs.core"
local motion = require("motion") ---@module "signs.motion"
local move, step = motion.move, motion.step

_G.Muse.places = _G.Muse.places or {}; place.places = _G.Muse.places -- **held as global across programs, not persistent**

--:# **Type definitions serialized for network tansport and disk storage**
--:> place: _A point, trail, or range_ -> `{name: ":", label: ":", :situations:, :features:}`
--:> features: _Dictionary of string key, any value pairs_ -> `[key: ":"]: any`

--:# **Utilities for places (points, trails, and ranges)**
function place.reset() place.places = {} end
--:: place.reset() -> _Resets places to the empty table._ -> `nil`
function place.count() return #place.places end
--:: place.count() -> _Returns number of places._ -> `#:`
function place.site(value) if value then _G.Muse.site = value end return _G.Muse.site end -- isolate global
--:: place.site(value: ":"?) -> _Set or return local `site` (isolates global)._ -> `":"`
function place.qualify(name) return name and (string.find(name, "%.") and name or place.site().."."..name) end
--:: place.qualify(name: ":") -> _Return already sited name, otherwise prepend site to name_ -> `sitedName: ":"`
function place.distance(a,b)  
--:: place.distance(a: xyzf, b: xyzf) -> _Manhattan: abs(delta x) + abs(delta y) + abs(delta z)._ -> `distance: #:`
  local ax, ay, az = table.unpack(a); local bx, by, bz = table.unpack(b)
  return math.abs(ax - bx) + math.abs(ay - by) + math.abs(az - bz)
end

local function xyzfSituation(situation, index) return move.at(situation), index end  
-- : xyzfSituation(:situation:, index: #:) -> _Faced position, default current situation_ -> `xyzf, index: #:`
--[[
```
<a id="match"></a>
The following is an unassuming little function right at the heart of `places`. It finds a `place`. Note that the lookup is of a `site` qualified name. The places in the `place.places` table shadow the global `_G.Muse.places`.

And after `place.match` is a function to report the coordinates and orientations associated with a `place`. There may be several as needed for a `trail` or a `range` named by the `place`.
```Lua
--]]
function place.match(name) 
  --:: place.match(name: ":") -> _Lookup place qualified by site, return_ `nil` _if not found._ -> `index: #:?, place?`
  local qualified = place.qualify(name); for index, placed in ipairs(place.places) do 
    if qualified == table.unpack(placed) then return index, placed end 
  end
end

function place.xyzf(target, number) -- target place or current situation position (with index for situations)
  --:: place.xyzf(name: ":"?, number: #:?) -> _Looks up name [defaults to current situation]._ -> `xyzf?, index: #:?`
  if not target then return xyzfSituation() end -- current position of this turtle
  local index, placed = place.match(target); if not index then return nil end
  local _, _, situations = table.unpack(placed); 
  number = number or 1; assert(number <= #situations, "places.xyzf: less than "..number.." situations")
  return xyzfSituation(situations[number], index) -- place situation 
end
--[[
```
<a id="name"></a> 
The following function, `place.name`, is the complement to `place.match`. Here's where places get remembered and the global `_G.Muse.places` gets changed. In the code below there are two concepts worth thinking about: serialization and what we're calling _features_. Features are just a dictionary included with a `place` to specify properties associated  with the `place` by other libraries. Serialization_ will be discussed in the context of <a href="../../Mining MUSE.html#persistence" target="_blank"> persistence </a> important to clients of `lib/places`. Follow the link if you want to explore it now.
```Lua
--]]
function place.name(name, label, supplied, features) -- newSituation(s) is from `place.trail` or `map.place` 
  --:: place.name(name: ":", label: ":", supplied: situation?, :features:??) -> _Make or update place._ -> `":", #:`
  --:+ _Include current situation or optionally supplied situation in places. Optionally update features with key = value._
  --:+ _Return index of situation in global places and the serialized situation including its features._
  local situation = supplied or move.clone(); features = features or {} -- clone to capture current situation
  local situations = #situation > 0 and situation or {situation} -- must be an array

  local index, matched = place.match(name); -- look for pre-existing
  local matching = matched or {"", "", {}, {}} -- initial structure for a place
  local _, _, _, matchedfeatures = table.unpack(matching); -- pre-existing
  for key, value in pairs(features) do matchedfeatures[key] = value end -- overwrite new

  local candidate = {place.qualify(name), label, situations, matchedfeatures} 
  local indexed = index or #place.places + 1; place.places[indexed] = candidate -- replace or new place
  core.report(4, "places", "name ", indexed, candidate)
  return core.serialize(candidate), indexed -- serialized for disk or net 
end
--[[
```
As mentioned, there may be a number of `situations` associated with a `place`. Here's how they get added. And how they all get forgotten (erased) locally at a turtle or other ComputerCraft computer.
```Lua
--]]
function place.add(name, situation)
--:: place.add(name: ":", :situation:) -> _Add situation to situations of an existing place._ -> `serialized: ":", index: #:`
  local index, matched = place.match(name); if not matched then return end
  local _, _, situations = table.unpack(matched); situations[#situations + 1] = situation
  return core.serialize(matched), index
end 

function place.erase(name) -- remove place if found
--::place.erase(name: ":") -> _Removes named place from array of places._ -> `#:, index: #:`
--:+ _Return new length of places table and the (previous) index of the removed place._
  local index = place.match(name); if index then table.remove(place.places, index) end
  return #place.places, index
end
--[[
```
<a id="where"></a> 
Implementing support for the "where" of things is straightforward. But look at `place.near` for a caution about the use of iterators.
```Lua
--]]
--:# **Answering "where?"**
local function placeSituation(name) -- situation for named place;
  local index, matched = place.match(name); if not index then return nil end
  local _, label, situations = table.unpack(matched); return situations[1], label
end
--[[
```
<a id="near"></a>
The upvalues of iterators establish part of its execution context. It's tempting to reference them in a `for` loop. Doing so, resets them to their initial value, generally not what's desired. 
```Lua
--]]

function place.near(span, reference) -- iterator: places in span distance of current situation|place or all places
--:: place.near(span: #:?, reference?: ":"|position) -> __ -> (): `name: ":", label: ":", xyz, distance: #:, situations, serial: ":"`
--:+ _If both the span and name or position are specified, return places within a span of blocks of the named place or position._
--:+ _If only the span is specified, return places within a span of blocks of the current situation or player position._
--:+ _If neither is specified return each of the named places. In any case, iterator returns include serialized places._
  local situation = type(reference) == "string" and placeSituation(reference) or _G.Muse.situation
  local xyzSituation = type(reference) == "table" and reference or {move.get(situation)}
  local index = 0; local count = #place.places;  -- upvalues for returned closure

  return function() -- the iterator; 
    -- **note: `for index = 1, count do` .... would reset the index every time the closure is invoked**
    while index < count do index = index + 1
      local namePlace, labelPlace, situations = table.unpack(place.places[index])
      local positionPlace = situations[1].position;
      local xyzPlace = {positionPlace.x, positionPlace.y, positionPlace.z}
      local distance = place.distance(xyzPlace, xyzSituation); if not span or distance <= span then 
        return namePlace, labelPlace, xyzPlace, distance, situations, core.serialize(place.places[index]) 
      end
    end
  end -- end closure
end
--[[
```
<a id="nearby"></a>
The `place.nearby` function demonstrates some potentially useful techniques: 
</br></br>
</ul>
<li>The `cardinals` argument of `place.nearby` is supplied by a higher level library that uses `place.nearby`. Other libraries that use `place.nearby` don't generate such a function but still have need of the rest of what `place.nearby` produces. Providing a placeholder dummy function deals with the situation.</li>
<li>The arguments of `place.nearby` are both optional and of different types. Checking the types allows binding to default values for the missing arguments.</li>
<li>The explicit and calculated features of each named place are accessed through an iterator, `place.near`, discussed just previously, which isolates the underlying global.</li>
<li>The call of `table.sort` includes an <a href="https://en.wikipedia.org/wiki/Anonymous_function" target="_blank">
_anonymous function_</a> that specifies how the sort is to be done.</li>
</ul></br>
```Lua
--]]
function place.nearby(xyzf, cardinals) -- dummy function is supplied for missing cardinals argument
--:: place.nearby(:xyzf:?, :cardinals:) -> _Sorted_ -> `:[distance: #:, name: ":", label: ":", cardinal: ":", :xyzf:]
--:> cardinals: _Function to get one of the eight cardinal points of the compass_ -> (dx: #:, dz: #:): cardinal: ":"
--:+ _Nearest places to specified xyzf coordinates or current position (as default)._ 
--:+ _Returned table is sorted by distances and includes the name, label, and xyzf position of each place._
--:+ _If a `cardinals` function is supplied, the eight point cardinal direction is also included._
  local reference = type(xyzf) ~= "table" and move.at() or xyzf; local x,_,z = table.unpack(reference); 
  cardinals = type(xyzf) == "function" and xyzf or (cardinals or function(dx, dz) return "" end) -- TODO: ???
  local namedPlaces = {}; for name, label, pxyz in place.near() do 
    local px, py, pz = table.unpack(pxyz); local distance = place.distance(pxyz, xyzf); 
    local position, cardinal = core.xyzf({core.round(px), core.round(py), core.round(pz)}), cardinals(px - x, pz - z)
    namedPlaces[#namedPlaces + 1] = {distance, name, label, cardinal, position}
  end; table.sort(namedPlaces, function(a,b) return a[1] < b[1] end) -- on `distance`
  return namedPlaces
end
--[[
```
<a id="trail"></a>
We've spoken about tracking when we looked at the implementation of <a href="motion.html#tracking" target="_blank">`lib/motion` </a>. Tracking is used to create a `trail`, a history of turtle movements that can be replayed forward or backwards and `moves` or `steps` a turtle along a trail.
```Lua 
--]]
--:# **Support for trails (names and labels for sequences of situations)**
function place.fix(xyzf, track) -- set position, possibly for trailhead if tracking
--:: place.fix(:xyzf:, track: ^:?) -> _Sets situation position, can start tracking for trail._ -> `xyzf`  
  move.set(table.unpack(xyzf)); move.track(track) -- enable tracking
  move.situations({move.clone()}); -- set first situation in trail
  return xyzf
end

local function reverseTrail(situations) -- get trail from end back to head
  local reversed = {}; local index = #situations; for _, situation in ipairs(situations) do 
    reversed[index] = situation; index = index - 1 -- new table, no mutation of `situation`, so no clone
  end; return reversed
end

function place.trail(headName, tailName, label) -- places for trail end and head 
--:: place.trail(headName: ":", tailName: ":", label: ":") -> _Makes two places._ -> `headSerial: ":", tailSerial: ":"`
--:+ _Trail places share a label and represent trails from head to tail and tail to head; head set by_ `place.fix`.
  local situations = move.clones() -- deep copy the track produced by `lib/motion`
  local headString = place.name(headName, label, situations) -- head place and end place share a label
  local tailString = place.name(tailName, label, reverseTrail(situations))
  move.situations({}); move.track(false) -- clean up and disable tracking
  return headString, tailString 
end

function place.track(name) -- return track elements of trail if trail exists
  --:: place.track(name: ":") -> _Returns trail_ -> `name: ":"?, label: ":"?, situations`?
  assert(name, "places: Need a name for trail")
  local index, matched = place.match(name); if not index then return nil end
  return table.unpack(matched) -- name, label, situations
end
--[[
```
Mostly just placing a naming layer on `move` and `step` but look at how iterators are handles in `steps.along`.
```Lua
--]]

--:# **Moving and stepping for known places: to points or along trails**
function moves.along(name) -- move along trail
--:: moves.along(name: ":") -> _Move from first to second situation of place._ -> `code: ":", remaining: #:, xyzf: ":" &! recovery`
--:+ _If the named place is the head of a trail, go from there to its tail. If it's a tail of a trail, go to its head._
  local _, _, situations = place.track(name); -- existing trail?
  if #situations == 0 then return "done", 0, move.ats() end -- note `{} ~= nil` however `#{} == 0`
  for _, situation in ipairs(situations) do local xyzf = xyzfSituation(situation); move.to(xyzf)
  end; return "done", 0, move.ats()
end

function steps.along(name) -- step from each situation to the next beginning with the current situation
--:: steps.along(name: ":") -> _Iterator: first to next situation of place._ -> `(): code: ":", remaining: #:, xyzf: ":" &! recovery`
--:+ _If the named place is the head of a trail, step from there to its tail. If it's a tail of a trail, step to its head._
  local _, _, situations = place.track(name); local iterators = {}; 
  local clonedSituations = core.clone(situations); -- deep copy because there's a mutation coming next
  table.insert(clonedSituations, 1, move.clone()) -- push a copy of the current situation onto the cloned table
  for index = 2, #clonedSituations do 
    local current, prior = clonedSituations[index], clonedSituations[index - 1]
    local xyzf = xyzfSituation(current) -- get xyzf from each what will be "current" situation 
    iterators[index-1] = step.to(xyzf, prior); 
  end; 

  return function()
    for index, iterator in ipairs(iterators) do -- exhausted iterators return `nil`
      local code, remaining, ats, direction, distance = iterator() -- iterator remembers remaining work
      if code then return code, remaining, ats, direction, distance, index end
    end -- this iterator complete
  end -- returns nil when all iterators completed
end

local function checkTarget(target)
  assert(target, "places: Need moves target to go there")
  local xyzfTarget = assert(place.xyzf(target), "places: Place to move to not found: "..target)
  return xyzfTarget
end

function moves.to(target, first) local xyzfTarget = checkTarget(target); return move.to(xyzfTarget, first) end
--:: moves.to(target: ":", first: ":") -> _Move to target, first along direction._ -> `code: ":", remaining: #:, xyzf: ":" &! recovery`

function steps.to(target) assert(target, "places: Need target to step there")
  --:: steps.to(target: ":") -> _Step (iterator) to target place._ -> `(): code: ":", remaining: #:, xyzf: ":" &! recovery`
  local xyzf = assert(place.xyzf(target), "places: Place to step to not found: "..target)
  return step.to(xyzf)
end
--[[
```
<a id="tables"></a> 
The library exports three tables: one to deal with names, one to deal with movement directed by those names, and one to deal with stepping through such movement. And that's it for the second of the MUSE foundation libraries. Head back to <a href="../../Mining MUSE.html#Chapter3"> _Mining MUSE_</a> for a discussion of persistence, distributed state, and much, much more!
```Lua
--]]
return {place = place, moves = moves, steps = steps}
